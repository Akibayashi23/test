
事実
* リリース承認会で、DEVチームは今回リリースする全ての機能とリスクを把握する必要があったが、個人的にはそれができていなかった。
原因
1. 手順書作成やリリース作業に意識を集中しすぎていたため、全体を把握する余裕がなかった。
2. リリースする機能が多く、全てを把握しきれていなかった。
3. リリース機能について質問が来ることを想定していなかった。
今後に向けてやりたいこと
1. 機能をリリースする際、実装チームとリリースチームの担当範囲を明確に整理する。
2. 2週間に1度リリースするような頻度で小規模リリースを行い、リリース工数を削減する仕組みを作る。
3. リリースノートに釘宮さんが知りたいポイントを事前に記載し、情報共有を強化する。
4. リリース承認会は各チーム代表者1人ずつ出る



事実
* 1204S-inにおいて、機能をまとめてリリースすることは非常にハードだった。
原因
1. 担当していない機能について、キャッチアップや情報整理が大変だった。
2. リリース機能が多い場合、特に担当外の機能に対するキャッチアップが負担となった。
今後に向けてやりたいこと
1. 2週間に1回リリースするなど、機能をこまめにリリースできる仕組みを構築する。
2. スプリントレビューを通過した機能を速やかにリリースできる体制を整える。




事実
* 仕様を十分に把握していない状況で、1からSTG/PRD走行確認書を作成しなければならなかった。
原因
1. リリースチームが1から仕様を把握し、結合試験書や走行確認書を作成するのは負担が大きかった。
2. 実装チームが仕様を最も深く理解しているため、正確なドキュメントを作成しやすい。
今後に向けてやりたいこと
1. 結合試験書と走行確認書は実装チームが作成し、STG結合試験担当チームが試験書を統合する
2. 走行確認書テンプレートを作成する（実装チームが走行確認書を更新していくイメージ)
3. STG/PRD走行確認チームは走行確認書を実施するのみとする。
4. 実装PBIの完了の定義に「走行確認書を更新していること」を追加すること



今後に向けて
①実装チームはリリース手順書/バックアウト手順書を作る。STG/PRDリリースチームが合体させる。
具体的にしたいこと
・実装チームは手順書を更新する場合はどのチームが更新したかをコメント追加する運用にする。
コメントにはPBIと何を更新したかを簡単に記載。もし難しければインラインコメントも可。
・テンプレート手順書はリリースチームがリリース作業実施後に修正/作成する。(実際にリリースしているため、正確な内容を記載できるため)(テンプレートを作成してほしければ、実装チームは手順書にコメントにテンプレートを作成して欲しい旨を記載する)
メリット
・リリース作業チームの手順書作成の工数を減らせる。
・PBIと手順書を紐づけられる。(リリースノートと比較し、手順書作成漏れがないか確認できる)
・どのチームが更新/作成した手順かすぐわかるため、リリース作業チームは聞きたいことあればすぐに実装チームとのコミュニケーションが取れる。
デメリット
・実装チームは手順書を更新/作成しなければならない。


②リリース日が決まっていない中でも、実装チケットに取り組む時点で、リリースノートとリリース準備チェックリストが準備されている状態にする。
具体例
・リリース担当チームはリリース準備チェックリストを今回リリース分と次回リリース分の2つ作る。
・実装チームは手順書とリリースノートの更新すべきところを更新する。(PBIの完了条件にする)
メリット
・リリース担当チームはリリースノートとリリース準備チェックリストの最終確認者(取りまとめ役)、STG/PRDリリース作業者として専念できる。
・リリース担当チームは手順書作成について、基本的には実施順を決めるだけで済む。
デメリット
・実装チームはリリースノートを更新、手順書を更新/作成しなければならない。



事実
* どんな機能をリリースするか明確でない状態から、リリース手順書やバックアウト手順書を作成しなければならず、非常に負担が大きく、ミスの可能性が高かった。
原因
* 現行の運用ではリリース手順書やバックアウト手順書をリリースチームが作成する形式だったため、負担が集中していた。
今後に向けてやりたいこと
① リリース手順書/バックアウト手順書の運用改善
1. 新しい運用フロー
    * 実装チームがリリース手順書とバックアウト手順書を作成し、STG/PRDリリースチームがそれを統合する。
2. 手順書更新運用
    * 実装チームが手順書を更新する際は、どのチームが更新したかをコメントに記載。コメントにはPBI番号や更新内容を簡潔に書く（インラインコメントでも可）。
3. テンプレート手順書の管理
    * テンプレート手順書はリリースチームがリリース後に修正・作成する。実装チームはテンプレート作成を希望する場合、コメントでリクエストを明記する。
メリット
* リリース作業チームの手順書作成工数が削減される。
* PBIと手順書が紐づけられるため、手順書作成漏れを防げる。
* 手順書の作成・更新者が明確になることで、コミュニケーションが迅速に行える。
デメリット
* 実装チームが手順書の作成・更新を担う負担が増える。
② リリース準備の早期着手
1. 新しい準備フロー
    * リリース日が未定の状態でも、実装チケットに取り組む段階でリリースノートとリリース準備チェックリストを準備する。
    * リリース担当チームは、今回リリース分と次回リリース分の2つのリリース準備チェックリストを作成する。
    * 実装チームは手順書とリリースノートを更新し、PBIの完了条件とする。
メリット
* リリース担当チームはリリースノートの確認やチェックリストの取りまとめ、リリース作業に集中できる。
* 手順書作成の工数が削減され、実施順を決めるだけで済む。
デメリット
* 実装チームにリリースノートの更新や手順書作成の負担が加わる。





リリースチケット対応時には以下が出揃っている状態になる。
・リリースノートにリリースする全ての機能
・リリース手順書
・バックアウト手順書
・走行確認書
結果として、スプリントの早い段階で、STGリリース、バックアウト、再リリースができる。
早い段階でリリースノートにリリース/バックアウトタイムスケジュールの実績値を記載でき、早い段階でリリース承認会を実施できる。


リリース手順書作成チケット→手順書取りまとめチケットに名称変えたい(SP1に変更)
やること
・リリース手順書の実施する順序を決める
・バックアウト手順書の実施する順序を決める
・リリースノートの機能詳細の表を見て、実施する手
順書に過不足ないか確認する。過不足あれば、開発チームと連携取って修正対応を行う
・手順書準備チェックリストを最新化する(これはリリース実施チケットにも入れたい項目)

STGリリース実施チケットSP3以下
やること(それぞれの手順で時間計測する)
・STGリリース
・STG走行確認
・STGバックアウト(STG試験完了後)
・STGバックアウト走行確認(ここまで完了したら、リリースノートのタイムスケジュールを更新)
・STG再リリース


PRDリリース実施チケット
・PRDリリース
・PRD走行確認


PBIに手順書テンプレート修正/作成


最終的なリリースまでの最短スケジュール
1日目　リリース手順書、バックアウト手順書、走行確認書完了、STG試験書作成完了、リリースノートのタイムスケジュール以外完了
2日目　STGリリース、STG試験、STGバックアウト、STGバックアウト総確、STGリリース、リリースノート完了(リリース承認会完了)
3日目　PRDリリース、PRD走行確認
4日目　S-in















# Status
- **Draft**: 記述中またはレビュー中

# Decision
リリースブランチとタグについて、セマンティックバージョンを統一する場合と統一しない場合の方針を検討する。依存関係のある複数のリポジトリ（A, B, C）におけるリリース戦略の選択肢は以下の2つである。

## 1. セマンティックバージョンを統一する場合

- **リリースブランチ**: すべてのリポジトリで、統一したセマンティックバージョンでリリースブランチを作成する。例：`release/1.1.0`
- **タグ**: セマンティックバージョンのタグをすべてのリポジトリで統一し、同じバージョンを付与する。例：`v1.1.0`

### 具体例：
- Aリポジトリのリリースブランチ名：`release/1.1.0`
- Bリポジトリのリリースブランチ名：`release/1.1.0`
- Cリポジトリのリリースブランチ名：`release/1.1.0`

すべてのリポジトリに対して、`v1.1.0` という統一されたタグを付けることで、バージョンの整合性が保証される。

### メリット：
- **依存関係の明確化**: すべてのリポジトリが同じバージョン番号でリリースされるため、どのリポジトリがどのバージョンに依存しているかが簡単に把握できる。
- **管理がシンプル**: プロジェクト全体で一貫したリリーススケジュールを保つことができ、バージョン管理が明確である。

### デメリット：
- **リリースの柔軟性が制限される**: 各リポジトリの開発スピードやリリース準備が異なる場合、すべてのリポジトリが同じタイミングでリリースされなければならないため、リリースが遅れる可能性がある。

## 2. セマンティックバージョンを統一しない場合

- **リリースブランチ**: 各リポジトリは独自のセマンティックバージョンでリリースブランチを持ち、進行状況に基づいて個別に管理される。例：`release/1.0.0`、`release/1.0.5`
- **タグ**: 各リポジトリは独自のセマンティックバージョンを使用し、リリースに応じたバージョン番号を付ける。例：Aリポジトリは `v1.0.0`、Bリポジトリは `v1.0.5`、Cリポジトリは `v2.0.0`

### 具体例：
- Aリポジトリのリリースブランチ名：`release/1.0.0` → タグ：`v1.0.0`
- Bリポジトリのリリースブランチ名：`release/1.0.5` → タグ：`v1.0.5`
- Cリポジトリのリリースブランチ名：`release/2.0.0` → タグ：`v2.0.0`

### メリット：
- **柔軟なリリース管理**: 各リポジトリが独立してリリースでき、他のリポジトリの進捗に左右されずに機能追加や修正が行える。
- **リリースのスピード向上**: 各リポジトリが独自のタイミングでリリースできるため、開発サイクルを加速できる。

### デメリット：
- **依存関係の追跡が複雑化**: 各リポジトリのバージョンが独立しているため、どのバージョンがどの依存関係に対応しているかを追跡するのが難しくなる。
- **バージョンの統一感が失われる**: ユーザーや開発者がどのバージョンを使用すべきか迷う可能性がある。

# Context
複数の依存関係のあるリポジトリ（A, B, C）が存在し、それぞれのリリースにおいてセマンティックバージョンを **統一するかどうか** を決定する必要がある。バージョンを統一すれば一貫したバージョン管理が可能だが、各リポジトリが異なる速度で開発を進めている場合には、バージョンの柔軟性が必要になる。これに対し、バージョンを統一しない場合は各リポジトリが独自にリリースできるが、依存関係の管理が複雑になる可能性がある。

# Consideration

### セマンティックバージョンを統一する場合
#### Pro:
- **依存関係の明確化**: すべてのリポジトリが同じバージョン番号（例：`v1.1.0`）でリリースされるため、どのバージョンが互いに対応しているかが一目で把握できる。
- **一貫性の確保**: リリース番号が統一されているため、リポジトリ間でバージョンの一貫性が保たれる。バージョン番号だけでリリースの内容を追跡できる。
- **管理が容易**: 複数のリポジトリが統一されたバージョン番号で管理されるため、プロジェクト全体のリリース管理が簡単になる。バージョンの追跡や整合性確認が容易になる。
- **テストや統合の調整がスムーズ**: リポジトリ間の統合テストや最終リリースに向けた調整がスムーズに行える。

#### Con:
- **柔軟性が低下**: 各リポジトリの開発スピードが異なる場合、すべてのリポジトリが同じバージョンに追従しなければならないため、リリースの柔軟性が低下する。
- **リリースタイミングの調整が難しい**: すべてのリポジトリを同時にリリースするため、個々のリポジトリの進捗が遅れると、全体のリリースが遅れるリスクがある。
- **大規模プロジェクトでは管理が複雑**: 各リポジトリで変更内容が多岐にわたる場合、一貫してバージョンを統一することが煩雑になり、管理の負担が増加する。

### セマンティックバージョンを統一しない場合
#### Pro:
- **柔軟なリリース管理**: 各リポジトリが独自にバージョン管理を行えるため、リリースタイミングや開発速度に応じてリリースできる柔軟性が高い。
- **個別リリースが可能**: 依存関係にかかわらず、個々のリポジトリの変更があれば速やかにリリースでき、他のリポジトリの進捗を待つ必要がない。
- **個別の修正が容易**: リポジトリごとに必要な修正や機能追加を独立してリリースでき、リリースサイクルが加速する。

#### Con:
- **依存関係の追跡が複雑化**: 各リポジトリが異なるバージョンを持つことで、どのバージョンがどの依存関係に対応しているかを追跡するのが難しくなる。
- **バージョン管理の統一感が失われる**: バージョンが統一されないため、ユーザーや開発者がどのバージョンを使用すべきか迷う可能性がある。
- **リリースの同期が難しい**: リリポジトリごとに異なるリリーススケジュールを取るため、リポジトリ間の統合テストやリリース調整が複雑になりやすい。

# Decision(仮)
現時点では、セマンティックバージョンを統一しない方針 を採用する。この方針は、各リポジトリの開発スピードやリリースタイミングに柔軟性を持たせることを目的としている。ただし、依存関係が複雑化するため、以下の対応を行い、依存関係の明確化とリリースの追跡を徹底する。

- 依存関係の明確化手段: 各リポジトリの依存関係は、package.json などで明示的に定義し、各リリースノートやドキュメントに依存関係のバージョン情報を必ず記載する。
- リリースノートの整備: 各リポジトリのリリース時に、変更点だけでなく依存関係に対する影響やバージョンをリリースノートに明確に記載する。GitHubのリリースノート自動生成機能を使用しつつ、手動で必要な情報を補足する。
- リリースタイミングの調整: 各リポジトリが異なるタイミングでリリースされるため、定期的なミーティングやCI/CDパイプラインで依存関係をチェックし、他のリポジトリへの影響がないことを確認する。

# Consequences

### セマンティックバージョンを統一しない場合
- 各リポジトリが独自のバージョンで管理され、柔軟なリリースが可能になる。依存関係の整合性はリリースノートや依存関係の明示によって管理する。
- リリース時には、他リポジトリへの影響をチェックし、必要に応じて相互調整を行う。
- 各リポジトリが異なるスピードで進行するため、リリースの柔軟性を保ちながらも依存関係の追跡を慎重に行う必要がある。

### セマンティックバージョンを統一する選択肢の検討（将来的な見直し）
- 各リポジトリの開発スピードが安定し、リリースタイミングを調整しやすくなった場合、セマンティックバージョンを統一することで管理の一貫性が高まり、依存関係の追跡も簡便化される可能性がある。状況に応じて、再検討することも視野に入れる。

# References
- [Semantic Versioning Specification (SemVer)](https://semver.org/)
- [GitHub Versioning Best Practices](https://docs.github.com/en/repositories/releasing-projects-on-github)

---

## GitHubのリリースノートについて
GitHubではリリースノート機能をサポートしている。詳細はこちら: [GitHub Automatically Generated Release Notes](https://docs.github.com/en/repositories/releasing-projects-on-github/automatically-generated-release-notes)

### リリースノートが必要な理由

#### 一貫性の確保
自動生成機能により、コミットメッセージやプルリクエストからリリース情報が抽出されるが、リリース情報の全体的な構造や内容が常に一貫して提示される。

#### 透明性の向上
手動でのリリースノート作成と自動生成機能を組み合わせることで、透明性の高いリリースプロセスを構築できる。自動生成された内容を確認し、必要に応じて追加情報やコメントをテンプレートに基づいて補足可能。

#### 効率化
自動生成されたリリースノートをテンプレート形式に整理することで、リリースにかかる作業時間を短縮できる。よりスピーディなリリースが可能になる。

#### 正確性の向上
すべての変更が漏れなくリリースノートに反映されるため、手作業による記載ミスや変更内容の漏れを防ぐことができる。

### 説明フィールドに記載する仮テンプレート
```md
# v1.1.0 - 2024-10-21

## 概要
- Full Changelog: (https://github.com/your-repo/your-project/commits/1.0.0)
- リリースノート：[コンフルリンク](https://your-confluence-link)

## 新機能
- チケットリンク
  - プルリクエスト: [#123](https://github.com/your-repo/your-project/pull/123)

## バグ修正
- チケットリンク
  - プルリクエスト: [#124](https://github.com/your-repo/your-project/pull/125)

## 改善
- チケットリンク
  - プルリクエスト: [#125](https://github.com/your-repo/your-project/pull/127)

## 既知の問題
- チケットリンク
