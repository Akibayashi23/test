
ログインが5回失敗したら、1時間ログイン不可のシステムで想定されるエラー文言について教えてください

ログインが5回失敗した後に1時間ログインができないようにするシステムにおいて、ユーザーに提示するエラー文言は以下のようになるかと思います：

1. 「ログインに5回連続で失敗しました。セキュリティのため、次の1時間はログインできません。」

2. 「連続したログイン失敗が検出されました。1時間後に再試行してください。」

3. 「安全性を保つため、あなたのアカウントは1時間ロックされています。後ほど再試行してください。」

4. 「ログイン試行が上限に達しました。1時間後に再度お試しください。」

上記の例のように、エラーメッセージはユーザーが何が起こったのか、なぜ起こったのか、そして何をすべきかを明確に理解できるように作成することが重要です。










質問以外にもデザインに比べて
画面設計の項目として足りないものやおかしな点、考慮した方がいい点、テーブルに関することなど気づいたことあれば記載いただきたいなと考えています。

画面設計のデザイン反映が間に合っていない状況に関しては大変申し訳ございません。

記載いただくことで画面設計の進捗も早められると思いますのでご協力の程、よろしくお願い致します🙇‍♂️



はい、システムの実装の観点から「先勝ち」と「後勝ち」のメリット・デメリットを考えることができます。

### 先勝ち:

**メリット**:
1. **安定性**: 一度リソースを取得したプロセスやタスクには、そのリソースが確保されるため、途中でリソースが変更されるリスクが少ない。
2. **データ整合性**: データベースのようなリソースにアクセスする際、先勝ちを採用することでデータの整合性を保つのが比較的容易になる。
3. **実装の一般性**: この方式は一般的であり、多くのライブラリやフレームワークでサポートされている。

**デメリット**:
1. **パフォーマンス**: リソースが占有されている間、他のプロセスは待機しなければならないため、システム全体の応答時間が遅くなる可能性がある。
2. **デッドロックのリスク**: 複数のリソースを取得する必要がある場合、デッドロックが発生する可能性がある。
3. **リソースの浪費**: ロックしているリソースを利用しない時間が生じることがある。

### 後勝ち:

**メリット**:
1. **高速な応答**: 最新の要求をすぐに処理するので、システムの反応が速くなる。
2. **シンプルな設計**: 以前のリクエストを気にせず、新しいリクエストだけを処理するので、システムの設計がシンプルになることが多い。
3. **リソースの節約**: 既存のリクエストを上書きすることで、リソースの使用量を削減できる場合がある。

**デメリット**:
1. **データ整合性のリスク**: 複数の操作が同時に発生する場合、データの整合性を保つのが難しくなる可能性がある。
2. **情報の喪失**: 以前のリクエストやデータが上書きされることで、それに関する情報が失われることがある。
3. **不明瞭な振る舞い**: 複数の要求が同時に発生した場合、どの要求が最終的に採用されるかが不明確になることがある。

これらのメリット・デメリットを考慮して、システムの要件や目的に合わせて実装方法を選択することが重要です。



先勝ちと後勝ちのアプローチは、システムの要件や目的によって異なる用途で利用されます。以下にそれぞれの用途について詳しく説明します。

### 先勝ち:

先勝ちのアプローチは、順番や公平性が重要な場面や、データの整合性を保ちたい場面で主に使用されます。

1. **データベースのトランザクション**: 2つのトランザクションが同時に同じデータを変更しようとする場合、先に来たトランザクションがそのデータにアクセスし、他のトランザクションは待機します。これにより、データの整合性が保たれます。

2. **ファイルシステム**: 複数のプロセスやスレッドが同時に同じファイルを書き込もうとする場合、先に来たものが書き込みを行い、後続のものは待たされることが多いです。

3. **キュー処理**: メッセージキューやタスクキューなどで、タスクやメッセージが順番に処理される必要がある場合に適しています。

### 後勝ち:

後勝ちのアプローチは、最新の情報や要求が最も重要であるとみなされる場面で主に使用されます。

1. **キャッシュの更新**: キャッシュに新しいデータが頻繁に書き込まれる場面で、最新のデータだけが重要である場合、後勝ちのアプローチが有効です。

2. **リアルタイム監視システム**: 例えば、センサーからのデータが連続的に送信される場面で、最新のデータだけが表示や分析の対象となる場合には後勝ちが適しています。

3. **ユーザーインターフェースの応答**: ユーザーが画面上のスライダーを動かして値を変更する場合など、連続した操作から最後の操作だけを取り込むために後勝ちのアプローチが使用されることがあります。

これらの例からもわかるように、先勝ちや後勝ちのアプローチは、システムの要件や状況に応じて適切に選択されるべきです。






ここには工数メモを記載する。

工数見積もりまとめ


前提
・過去タスクとの比較できない
・Angular未経験
※頭でシミュレーションすることが大切だと心得る
・期限を確定させるから、慎重に行う

工数の対象
・設計
・実装
・単体テスト
　正しい？


工数を算出したいタイミング
・理想は画面設計完了、デザインコーディング完了のタイミング
　画面設計とデザインコーディングを比較して、足りない機能単位で工数を積み上げたい。
・タスクをより細分化して、工数を見積もりたい。
※いずれにしても、機能単位で工数見積もるなら、今からでもできる。
※ただ、同時並行でやる？


現実的なのは下記
⭐︎画面設計修正しながら、機能単位で機能を画面ごとに洗い出す。
画面設計完了後、機能が揃っているので、その機能が子コンポーネント化されているか、共通の機能があるかを識別して、機械的に工数を算出していきたい。
→画面設計完了をトリガーとして、工数を算出できる状態にする。

8月末が理想。
根拠やリスクや難易度を詳細に記載できる。





工数算出表
画面、機能、概要、難易度(高、中、低)、工数時間、工数人日、根拠、不確定要素(リスク)
・難易度がついているものは工数の見積もりが正確でない可能性が高い
・画面の中でも共通
→画面一覧が参考になる



工数の算出時間
・理想時間と現実時間があって、1日6時間の力しか発揮できないと考える。
・1日4〜6時間を工数として見積もり残りの時間はバッファとして考える。
・定例ミーティングなどの作業外の時間を加味した工数見積もりを行う
　不確実な作業が発生することを想定して、バッファを設ける
※バッファを良しとしないこともある。バッファはこちらで考えず、レビュアーに算出いただく。
※バッファをこちらで考える必要があるのかを共有する必要がある。PMがバッファを見積もればいいと思っている。
※×1.25〜1.5が自然とバッファになるように工数を算出する。バッファ抜きで工数を算出



工数見積もりのポイント
・楽観値
・最頻値
・悲観値
上記のどれに該当し、受け取り手にも伝わるようにする
　基本的に最頻値で出せるように意識する。
　楽観値は×0.5
　悲観値は×1.5


難易度が高そうな実装の工数算出
・うまくいく場合とそうでない場合で場合分けする。
  バグが発生しそうだから、通常の1.5倍で工数を設定する
　想定できないエラーが発生する可能性もある。
・エリア選択





具体的な工数細分化方法
・タスクを細分化させる
　1つのタスクが3時間以下になるまで細分化
・細分化したタスクを足し合わせて、合計させる。
・タスクを細分化して、作業遅れをいち早く認識し、アラートを早めに上げられるようにする。
・画面単位で工数を算出したくない。機能単位で工数を算出したい。
　理由としては、気付けなかった機能や追加機能に対応がキツくなる。機能単位で工数を算出して、最終的に画面単位の工数になるとしたい。
・メンバーのスキルに合わせた工数を算出している



作成方法
・工数は2人で別々で作成して、一斉ので出す。
・最初に時間換算して、後で人日計算に戻す。
→Excelで自動的にやる



0.5時間 = 0.5/8人日 = 0.0625人日
1. 1時間 = 1/8人日 = 0.125人日
2. 2時間 = 2/8人日 = 0.25人日
3. 3時間 = 3/8人日 = 0.375人日
4. 4時間 = 4/8人日 = 0.5人日
5. 5時間 = 5/8人日 = 0.625人日
6. 6時間 = 6/8人日 = 0.75人日
7. 7時間 = 7/8人日 = 0.875人日

これらの数値は、時間を人日で表現する際の変換率として使用できます。





参考) https://qiita.com/taku-0728/items/7a2f0919ce375bbb48f7








<template>
  <v-text-field
    v-model="input"
    label="半角数字とハイフンのみを入力してください"
    @input="validateInput"
  ></v-text-field>
</template>

<script>
export default {
  data() {
    return {
      input: ''
    }
  },
  methods: {
    validateInput() {
      const regex = /^[\d-]*$/ // 半角数字とハイフンのみを許可する正規表現
      if (!regex.test(this.input)) {
        this.input = this.input.replace(/[^\d-]/g, '') // 半角数字とハイフン以外の文字を削除する
      }
    }
  }
}
</script>



<template>
  <v-text-field
    v-model="input"
    label="半角数字とハイフンのみを入力してください"
    @input="validateInput"
  ></v-text-field>
</template>

<script>
export default {
  data() {
    return {
      input: ''
    }
  },
  methods: {
    validateInput() {
      this.input = this.input.replace(/[^\d-]/g, '')
    }
  }
}
</script>
